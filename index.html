<center>
<canvas id=canvas width=704 height=704 style="border:9px solid; background:#ddd">
<script src=levels.js></script>
<script>

// Global vars

cellsize = 64;
gridsize = 11;

w = .6;
h = .8;

speed_x = 0.16;

gravity = .045;
jump = -.3;
vymax = 1;

heroscale = 1;
padding = speed_x + 0.01;
c=canvas.getContext("2d");
canjumpagain = 0;

currentlevel = 6;

// Keyboard
E=R=T=_=s=e=u=d=l=r=0;
onkeydown=onkeyup=z=>{
  
  top['lurdlRdTl*urEu*_e**s'[(z.which+3)%20]]=z.type[3]<'u';
  if(!u) canjumpagain = 1;
}

// Get cell value at x:y
get = (x, y) => {
  X = Math.floor(x);
  Y = Math.floor(y);
  return parseInt(m[Y * gridsize + X]);
}

// Check if cell at x:y is solid
isSolid = (x,y) => {
  if(get(x,y)==1) return 1;
  if(get(x,y) == 4) return 1;
  //if(y == 11 - h) return 1;
  if(levels[currentlevel].keys){
    for(i in levels[currentlevel].keys){
      if(levels[currentlevel].keys[i].taken){
        for(j in levels[currentlevel].keys[i].on){
          if(Math.floor(x) == levels[currentlevel].keys[i].on[j][0] && Math.floor(y) == levels[currentlevel].keys[i].on[j][1]){
           return 1;
          }
        }
      
      }
      
      else{
        for(j in levels[currentlevel].keys[i].off){
            if(Math.floor(x) == levels[currentlevel].keys[i].off[j][0] && Math.floor(y) == levels[currentlevel].keys[i].off[j][1]){
             return 1;
            }
          }
      
      }
    }
  }
  return 0;
}

// Load a level
load = n => {
  dead = 0;
  x = levels[currentlevel].start[0];
  y = levels[currentlevel].start[1];
  vx = 0;
  vy = 0;
  grounded = 0;
  shifted = 0;
  shiftframe = 0;
  heroscale = 1;
  wonframe=0;
  m=levels[currentlevel].map;
  canvas.style.transform = "";
  for(i in levels[currentlevel].keys){
    levels[currentlevel].keys[i].taken = 0;
  }
}

load(0);

// Game loop
setInterval(()=>{

  //console.log("===");

  // Reset
  canvas.width = canvas.width;
  
  c.save();
  if(shiftframe>0 && shiftframe<10){
    canvas.style.transform = "rotate(" + ((10 - shiftframe) * 3.14/9) + "rad)";
    if(shiftframe==1){
      m=m.split("").reverse().join("").replace(/0/g, "A").replace(/1/g, 0).replace(/A/g,1).replace(/3/g, "A").replace(/4/g, 3).replace(/A/g,4);
      canvas.style.transform = "";
      x = 11 - x;
      y = 11 - y;
      y--;
      shifted = 1 - shifted;
      heroscale = 1;
    }
  }
  // Draw map
  if(wonframe > 10 || wonframe == 0){
    for(i=0;i<gridsize;i++){
      for(j=0;j<gridsize;j++){
        a=(m[j*gridsize+i]);
        
        // Black cell
        if((!shifted && a==1)||(shifted && a==0)){
          c.fillRect(i*cellsize,j*cellsize,cellsize,cellsize);
        }
        
        // Spike when not shifted
        else if(a==2 && !shifted){
          c.moveTo(i*cellsize, j*cellsize + cellsize);
          c.lineTo(i*cellsize + cellsize/4, j*cellsize);
          c.lineTo(i*cellsize + cellsize/2, j*cellsize + cellsize);
          c.lineTo(i*cellsize + cellsize/4*3, j*cellsize);
          c.lineTo(i*cellsize + cellsize, j*cellsize + cellsize);
          c.fill();
        }
        // Spike when shifted
        else if(a==2 && shifted){
          c.moveTo(i*cellsize, j*cellsize);
          c.lineTo(i*cellsize + cellsize/4, j*cellsize + cellsize);
          c.lineTo(i*cellsize + cellsize/2, j*cellsize);
          c.lineTo(i*cellsize + cellsize/4*3, j*cellsize + cellsize);
          c.lineTo(i*cellsize + cellsize, j*cellsize);
          c.fill();
        }
        
        // Door on white cell
        else if((!shifted && a==3)||(shifted && a==4)){
        
          // Door
          c.fillStyle="#888";
          c.fillRect(i*cellsize+10,j*cellsize + (shifted ? 0 : 10),44,54);
          
          c.fillStyle="#000";
        }
        
        // Door on black cell
        else if((!shifted && a==4)||(shifted && a==3)){
          
          // Black cell
          c.fillRect(i*cellsize,j*cellsize,cellsize,cellsize);
          
          // Door
          c.fillStyle="#888";
          c.fillRect(i*cellsize+10,j*cellsize + (shifted ? 10 : 0),44,54);
          
          c.fillStyle = "#000";
          
          
        }
      }
    }
    
    if(levels[currentlevel].keys){
      c.fillStyle = "#aaa";
      for(i in levels[currentlevel].keys){
      console.log(levels[currentlevel].keys[i].taken);
        if(!levels[currentlevel].keys[i].taken){
            c.beginPath();
            c.arc(levels[currentlevel].keys[i].key[0] * cellsize  + cellsize/ 2, levels[currentlevel].keys[i].key[1] * cellsize + cellsize / 2, cellsize / 4, 0, 6.29);
            c.fill();
            c.closePath();
            
            // draw platform mode on
            for(j in levels[currentlevel].keys[i].off){
              c.fillRect(levels[currentlevel].keys[i].off[j][0] * cellsize, levels[currentlevel].keys[i].off[j][1] *cellsize, cellsize, cellsize);
            }
           
          }
          // draw platform mode off
        else{
          for(j in levels[currentlevel].keys[i].on){
              c.fillRect(levels[currentlevel].keys[i].on[j][0] * cellsize, levels[currentlevel].keys[i].on[j][1] * cellsize, cellsize, cellsize);
            }
        
        }
      }
    }
    
    // Text
    if(levels[currentlevel].msg){
      c.font = '20px "Comic Sans MS", cursive, sans-serif';
      c.fillStyle = levels[currentlevel].msg[3];
      c.save();
      if(levels[currentlevel].msg[3] == "#fff" ^ shifted){
        c.translate(350,350);
        c.rotate(3.14);
        c.translate(-350,-350);
      }
      c.fillText(levels[currentlevel].msg[0],levels[currentlevel].msg[1],levels[currentlevel].msg[2]);
      c.restore();
    }
  }
  
  // Press shift
  if(s){
    if(!shifted && (isSolid(x,y+h) && isSolid(x+w,y+h))){
      shiftframe = 20;
    }
    else if(shifted && (isSolid(x,y+h) && isSolid(x+w,y+h))){
      shiftframe = 20;
    }
  }
  
  else if(wonframe){
    wonframe--;
    if(wonframe == 1){
      load(++currentlevel);
    }
  }
  
  else {
    //console.log(canjumpagain);
    
    if(dead){
      load(currentlevel);
    }
    
    // Apply speed to pos
    if(r){
      vx = speed_x;
    }
    else if(l){
      vx =-speed_x;
    }
    else{
      vx=0;
    }
    if(grounded && u && canjumpagain){  // jump
      canjumpagain = 1 - canjumpagain;
      vy = jump;
    }
    if(1-grounded){   // fall
      vy += gravity;
      vy = Math.min(vy, vymax);
    }
    y += vy;
    x += vx;
    
    // Check collisions:
    // - Hit screen: left, right, down or up
    // - Hit Box when going left, right, down or up

    // Hit screen bottom
    if(y + h > gridsize){
      //console.log("hit screen bottom");
      y = gridsize - h;
      vy = 0;
    }
    // Hit screen ceiling
    if(y<0){
      //console.log("hit screen ceiling");
      y = 0;
      vy = 0;
    }
    // Hit screen left
    if(x<0){
      //console.log("hit screen left");
      x=0;
    }
    // Hit screen right
    if(x + w >gridsize){
      //console.log("hit screen right");
      x = gridsize - w;
    }
    
    // Hit Box up
    if((isSolid(x,y) && isSolid(x + padding,y))  || (isSolid(x+w,y) && isSolid(x+w - padding,y))){
      console.log("hit box up");
      vy=0;
      y = Math.ceil(y);
    }

    // Hit Box down
    if((vy >= 0) && ((isSolid(x,y + h) && isSolid(x+padding,y + h)) || (isSolid(x + w, y + h) && isSolid(x + w - padding, y + h)))){
      console.log("hit box down");
      vy = 0;
      y = Math.floor(y + h) - h;
    }

    // Hit box Left
    if((isSolid(x, y) && isSolid(x, y+padding)) || (isSolid(x, y+h) && isSolid(x, y+h - padding))){
      console.log("hit box left");
      x = Math.ceil(x);
    }

    // Hit box right
    if((isSolid(x+w,y) && isSolid(x+w,y+padding)) || (isSolid(x+w, y+h) && isSolid(x+w, y+h - padding))){
     console.log("hit box right");
      x = Math.floor(x + w) - w;
    }

    // Check spikes
    if(get(x,y) == 2 || get(x,y+h-.1) == 2 || get(x+w,y) == 2 || get(x+w,y+h-.1) == 2){
      dead = 1;
    }
    
    // Test grounded
    if((isSolid(x, y+h) && isSolid(x + padding, y+h)) || (isSolid(x+w - padding, y+h) && isSolid(x+w, y+h))){
      grounded = 1;
    }
    else{
      grounded = 0;
    }   
    
    // Test door
    if(grounded && get(x,y) == 3 && get(x+w,y) == 3){
      wonframe = 30;
    }
    
    for(i in levels[currentlevel].keys){
      if(!levels[currentlevel].keys[i].taken && Math.floor(x) >= levels[currentlevel].keys[i].key[0] && Math.floor(x) < levels[currentlevel].keys[i].key[0] + 1 && Math.floor(y) >= levels[currentlevel].keys[i].key[1] && Math.floor(y) < levels[currentlevel].keys[i].key[1] + 1){
        levels[currentlevel].keys[i].taken = 1;
      }
    }
  }
    
  // Draw hero
  c.fillStyle="#468";
  c.save();
  c.translate(x*cellsize+w*cellsize/2,y*cellsize+h*cellsize);
  c.scale(1, heroscale);
  c.fillRect(-w*cellsize/2,0, w*cellsize, -h*cellsize);
  c.restore();
    
  //c.font="60px a";
  //c.save();
  //c.translate(x, y);
  //c.scale(-1,1);
  //c.fillText("🏃\ufe0e", 0, 0);
  //c.restore(); 

  // Shift animation
  if(shiftframe) {
    shiftframe--;
    if(shiftframe >= 10){
      heroscale = -((15 - shiftframe) / 5);
      
    }
  }
  
  // Won transition
  if(wonframe && wonframe < 10){
    c.fillStyle = "#000";
    c.fillRect(0,0,704,704);
  }
  
  askshift = 0;
  
},33);

</script>
